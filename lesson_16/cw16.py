#---------- Easy A ----------#

def rec() -> None:              # Функция ничего не принимаем и ничего возвращает
    print("This is recursion")  # Печатаем текст
    rec()                       # Вызываем функцию еще раз

rec() # Вызов функций





#---------- Easy B ----------#

def one_to_n(num: int) -> None: # Функция получает число, ничего не возвращает
    if num == 0:                # Число будет постепенно уменьшаться
        return                  # Если дойдет но 0, останавливаемся 
    else:
        one_to_n(num-1)         # Иначе вызываем функцию еще раз с меньшим числом
        print(num, end=" ")     # После завершения вызова, печатаем текущее число

number = int(input())           # Принимаем число с консоли
one_to_n(number)                # Вызываем функцию передав наше число





#---------- Easy C ----------#

def factorial(num: int) -> int:         # Принимаем целое число, возвращается целое число
    if number == 0 or number == 1:      # 1! = 1    и   0! = 1
        return 1
    else:                               # Для остальных чисел используем данную формулу
        return num * factorial(num-1)   # n! = n * (n-1)!

number = int(input("Число: "))          
res = factorial(number)                 # Вызываем функцию, передаем number. Ответ функций сохраняем в переменную res
print(f"{number}! = {res}")             # Выводим ответ





#---------- Easy D ----------#

def accerman(m:int, n:int) -> int:      # Функция принимает два числа 
    if m == 0:                          # По показанным условиям
        return n + 1                    # Возвращаем показанные значения
    elif m > 0 and n == 0:
        return accerman(m - 1, 1)
    elif m > 0 and n > 0:
        return accerman(m - 1, accerman(m, n - 1))
    
m, n = int(input()), int(input())       # Принимаем два числа 
print(accerman(m, n))                   # Печатаем ответ вызванной функций передав два значения





#---------- Medium A ----------#

def sum_of_digits(number: int) -> int:  # Функция получает int, возвращает сумму(int)
    if number == 0:                     # Если число 0
        return 0                        # То и сумма его цифр 0
    
    else:                               # Для остальных чисел будет по такому примеру: 
        return number%10 + sum_of_digits(number//10)        
                                        # Как пример возьмем число 1475
                                        # Сумма его цифр будет [последняя цифра] + [сумма остальных цифр]
                                        # 5 + sum_of_digits(147)

number = int(input("Число: "))
print(f"Сумма: {sum_of_digits(number)}")





#---------- Medium B ----------#

def my_sum(a: list) -> int|float:   # Функция принимает список чисел, возвращает сумму(int или float)
    if len(a) == 0:                 # Если в списке нет элементов
        return 0                    # то сумма = 0
    elif len(a) == 1:               # Иначе-если в списке только один элемент
        return a[0]                 # суммой будет считаться сам элемент
    else:                           # Иначе говорим что сумма это
        return a[0] + my_sum(a[1:]) # [нулевой элемент] + [сумма остальных элементов]
0
nums = list(map(int, input().split()))
print(my_sum(nums))





#---------- Medium C ----------#

def is_power_of_2(number: int) -> bool:     # Функция получает число, и возвращает True или False
    if number == 1:                         # Число будет каждый раз делиться на 2
        return True                         # Если когда то достигнем до ровно 1, то это степень 2
    elif number < 1:                        # Если упадет ниже 1, значит не степень 2
        return False
    else:                                   # В остальных случаях
        return is_power_of_2(number / 2)    # Вызываем функцию, поделив число на 2

number = int(input("Число: "))
if is_power_of_2(number):           # Если функция возвращает True, получив наше число
    print("YES")                    # то это степень двойки
else:
    print("NO")                     # Иначе нет





#---------- Hard A ----------#

# Функция получает наше число, так же будет опциональный параметр k = 2
def divs(number: int, k = 2) -> None:
    if number == 1:             # Если число 1, то нет делителей, функцию завершаем
        return              
    elif number % k == 0:       # Если число делиться на k
        print(k, end=" ")       # Выводим его делитель
        divs(number // k, k)    # Вызываем функцию еще раз, поделив число на k, сам k не меняеться
    else:
        divs(number, k+1)       # А если не делиться, вызываем функцию, увеличиваяя k, тем самым будет искать другие делители


n = int(input("Число: "))       
divs(n) # Вызов функций





#---------- Hard B ----------#

# Заранее прогуглите алгоритм перевода десятичного цисла в двоичное
def binary(number: int, res="") -> str: # Функция получает число, и опциональный параметр res с пустой строкой
    if number == 0:                     # Число будет постепенно целочисленно делиться на 2
        return res                      # Когда дойдет до 0, завершаем функцию
    else:
        res = str(number%2) + res       # Добавляем остаток от деления на 2 в начало строки
        return binary(number//2, res)   # Вызываем функцию еще раз, поделив число на 2

n = int(input("Число: "))
result = binary(n)
print(result)





#---------- Hard C ----------#

def reverse_int(number: int, res=0) -> int:
    if number == 0:         # Число будет постепенно целочисленно делиться на 10
        return res          # Когда дойдет до 0, завершаем функцию возвращая res
    else:                   # Иначе вызывем функию, целочисленно поделив число на 10(избавляемся от последней цифры)
                            # и в качестве res будет res * 10 + [последняя цифра]
                            # Например: res=54, посл. цифра 7, по такой формуле мы получим 547. (Последнюю цифру добавили в конец)
        return reverse_int(number//10, res*10 + number%10)

n = int(input("Число: "))
print(f"{n} => {reverse_int(n)}")